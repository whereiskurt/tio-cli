package vulnerability

import (
  "fmt"
  "os"
  "strconv"
  "strings"
  "sync"
	"time"
  "github.com/briandowns/spinner"
  "github.com/whereiskurt/tio-cli/internal/pkg/tio"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/api/tenable"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/cache"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/dao"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/ui"
)

type Cache struct {
	Config            *tio.VulnerabilityConfig
	Workers           *sync.WaitGroup
	ConcurrentWorkers int
}

func NewCache(config *tio.VulnerabilityConfig) (h *Cache) {
	h = new(Cache)
	h.Config = config

	h.Workers = new(sync.WaitGroup)
	h.ConcurrentWorkers, _ = strconv.Atoi(config.Base.ConcurrentWorkers)

	return h
}

func (h *Cache) Execute() error {
  configSuccess:=h.Config.Base.IsSuccessState
  syncMode := h.Config.SyncMode
  shouldAnon := h.Config.ShouldAnon

  trans := dao.NewTranslator(h.Config)

  if shouldAnon == true {
    trans.Infof("ANONYMIZER: Attaching Anonymizer.")
    trans.Anonymizer = tenable.NewAnonymizer(h.Config)
  }

  cli := ui.NewCommandLineInterface(h.Config.Base)
  
  h.OutputBanner(trans, cli)

  if !configSuccess {
    cli.PromptForConfigKeys()
    cli.Println(fmt.Sprintf("\nRe-execute 'tio-cli' command.\n"))
    return nil
  }

  //Remove ScanList and ScanDetails for scans
  if syncMode == true {
    portal := cache.NewPortalCache(h.Config.Base)
    filename, _ := portal.PortalCacheFilename("/scans")
    cli.Println(fmt.Sprintf("  -> DELETING: Index '%s' ", filename))
    os.Remove(filename)
    for _, scanId := range strings.Split(h.Config.ScanId, ",") {
      filename, _ := portal.PortalCacheFilename("/scans/" + scanId)
      if filename == "" { continue }

      cli.Println(fmt.Sprintf("  -> DELETING: '%s' (id:%v) ...", filename, scanId ))
      os.Remove(filename)
    }
    //TODO: Clear out folders/files based on these params too!
    // for _,historyId := range strings.Split(h.Config.PluginId, ",") { }
    // for _,pluginID := range strings.Split(h.Config.PluginId, ",") { }
  }

  ch := make(chan dao.ScanHistory, h.ConcurrentWorkers)

  go trans.GoGetHostDetails(ch, h.ConcurrentWorkers)

  scans, _ := trans.GetScans()

  scanCount := len(scans)
  depth, _ := strconv.Atoi(h.Config.Depth)
  //totScans := depth * scanCount

  s := spinner.New(spinner.CharSets[9], 200*time.Millisecond)  
  s.Writer = h.Config.Base.Output

  h.OutputExecutionPlan(trans, cli)

  i := 0
  s.Prefix = fmt.Sprintf("  -> Fetching '%v' total Scans with HostDetails for '%v' histories ... ", scanCount, depth) 
  s.Start()
  for rec := range ch { 
    hostCount := 0
    for _,sd := range rec.ScanHistoryDetails {
      count, _ := strconv.Atoi(sd.HostCount)
      hostCount = hostCount + count
    }
    i = i + 1
    s.FinalMSG = fmt.Sprintf("  %v) '%v' (id:%v) cached '%v' hosts.\n", i, rec.Scan.Name, rec.Scan.ScanId, hostCount)
    s.Stop()
    s.Prefix = fmt.Sprintf("  -> Fetching host details for '%v' more scans ... ", scanCount - i) 
    s.Restart()
  }
  s.FinalMSG = fmt.Sprintf("\nCompleted!\n")
  s.Stop()

  trans.Debugf(fmt.Sprintf("Stats: tenable.portal:%#v", trans.PortalCache.Portal.Stats.GetCounts()))
  trans.Debugf(fmt.Sprintf("Stats: tio.cache:%#v", trans.PortalCache.Stats.GetCounts()))
  trans.Debugf(fmt.Sprintf("Stats: dao.translator:%#v", trans.Stats.GetCounts()))

  h.OutputFooter(trans, cli)

  return nil
}

func (h *Cache) OutputBanner(trans *dao.Translator, cli *ui.CommandLineInterface)  {
  dts := h.Config.Base.ExecutionDTS
  cli.Println(
"                _ \n" +
" tio-cli v0.5  | |\n" +
"  ___ __ _  ___| |__   ___\n" +
" / __/ _` |/ __| '_ \\ / _ \\\n" +
"| (_| (_| | (__| | | |  __/\n" +
" \\___\\__,_|\\___|_|_|_|\\___|\n" +
"---------------------------------\n" +
"Execution: " + fmt.Sprintf("%v", dts) + "\n")

  return
}

func (h *Cache) OutputExecutionPlan(trans *dao.Translator, cli *ui.CommandLineInterface)  {
  scans, _ := trans.GetScans() 
  scanCount := len(scans)
  depth, _ := strconv.Atoi(h.Config.Depth)
  totScans := depth * scanCount
  
  cli.Println(fmt.Sprintf("%v", `
Will attempt to locally cache '` + fmt.Sprintf("%v",scanCount) + `' scans from Tenable.IO 
with a history depth of '` + fmt.Sprintf("%v", depth) + `' (` + fmt.Sprintf("%v", totScans) + ` total scan lookups) ` + "\n"))

  return
} 

func (h *Cache) OutputFooter(trans *dao.Translator, cli *ui.CommandLineInterface)  {
  stats := trans.Stats.GetCounts()
  portalStats :=  trans.PortalCache.Stats.GetCounts()

  scans, _ := trans.GetScans()

  scanCount := len(scans)
  depth, _ := strconv.Atoi(h.Config.Depth)
  totScans := depth * scanCount
  //calls := stats["tio.dao.GetScan.CallCount"]

  cli.Println(
"\n"+
"Total Scans SUCCESS: " + fmt.Sprintf("'%v' scans with history depth of '%v' ('%v' total lookups)", scanCount, depth, totScans ) + "\n" + 
"Total Hosts SUCCESS: " + fmt.Sprintf("'%v' hosts cached", stats["tio.dao.GetHostDetail.CallCount"]) +  "\n" +
"Total Hosts FAILED: " + fmt.Sprintf("'%v' hosts failed to cache", stats["tio.dao.GetHostDetail.ErrorBadData"]) +  "\n" +
"\n"+
"Total DISK CACHE: " + fmt.Sprintf("%v", portalStats["tio.cache.HIT"]) + " HITS / " + fmt.Sprintf("%v", portalStats["tio.cache.MISS"]) + " MISSES\n" )

// Total API GET calls made to Tenable.IO: trans.PortalCache.Portal.Stats['tio.api.GET.Success']
//       API calls 'bad data': trans.PortalCache.Stats['tio.dao.GetHostDetail.ErrorBadData']

// `)

}