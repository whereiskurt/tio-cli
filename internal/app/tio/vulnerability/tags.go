package vulnerability

import (
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/whereiskurt/tio-cli/internal/pkg/tio"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/dao"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/ui"
)

type Tags struct {
	Config            *tio.VulnerabilityConfig
	Workers           *sync.WaitGroup
	ConcurrentWorkers int
}

func NewTags(config *tio.VulnerabilityConfig) *Tags {
	s := new(Tags)
	s.Config = config

	s.Workers = new(sync.WaitGroup)
	s.ConcurrentWorkers, _ = strconv.Atoi(config.Base.ConcurrentWorkers)

	return s
}

func (t *Tags) Execute() (err error) {

	tagCategory := t.Config.TagCategory
	tagValue := t.Config.TagValue

	//CREATE or DELETE??
	if t.Config.Create == true {
		err = t.CreateTag(tagCategory, tagValue)
		if err == nil {
			err = t.ListTags(tagCategory, tagValue)
		}
		return err
	} else if t.Config.Delete == true {
		err = t.DeleteTag(tagCategory, tagValue)
		if err == nil {
			err = t.ListTags(tagCategory, "")
		}
		return err

		return err
	}

	//LIST or SEARCH ??
	if !(t.Config.Tag || t.Config.Untag) {
		if t.Config.SearchView == true {
			return nil

		} else if t.Config.ListView == true {
			err = t.ListTags(tagCategory, tagValue)

			return err
		}
	}

	//TAG or UNGAG an asset
	//TODO: Split assetUUID and loop on a command-separated assetUUID list
	if t.Config.AssetUUID != "" {
		assetUUID := t.Config.AssetUUID
		if t.Config.Tag == true {
			err = t.Tag(assetUUID, tagCategory, tagValue)

		} else if t.Config.Untag == true {
			err = t.Untag(assetUUID, tagCategory, tagValue)

		}
		return err
	}

	//TAG or UNTAG many based on command parameters (--scanId, --hostId, etc.)
	err = t.LoopOnHostDetails(tagCategory, tagValue)

	return err
}

func (t *Tags) LoopOnHostDetails(tagCategory string, tagValue string) (err error) {

	var trans = dao.NewTranslator(t.Config)
	trans.Info("Executing tio.vulnerability.tags.Execute()")

	//Use the scan history and scanid,hostid,pluginid,etc.
	ch := make(chan dao.ScanHistory, 2)

	go trans.GoGetHostDetails(ch, 6)

	for rec := range ch {
		if len(rec.ScanHistoryDetails) == 0 {
			continue
		}
		scan := rec.ScanHistoryDetails[0]
		hosts := scan.Host
		for _, h := range hosts {
			assetUUID := h.Asset.UUID

			if t.Config.Tag == true {
				err = t.Tag(assetUUID, tagCategory, tagValue)

			} else if t.Config.Untag == true {
				err = t.Untag(assetUUID, tagCategory, tagValue)

			}

			if err != nil {
				trans.Errorf("ERROR: %s", err)

				break
			}

		}
	}

	return err
}
func (t *Tags) CreateTag(tagCategory string, tagValue string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)

	if tagCategory == "" || tagValue == "" {
		err = errors.New("ERROR: Must provide a CATEGORY NAME and VALUE.")
		cli.Println(fmt.Sprintf("%s", err))
		trans.Errorf("%s", err)
		return err
	}

	categories, err := trans.GetTagCategories()
	if err != nil {
		trans.Errorf("Error: %s", err)
		return err
	}

	var categoryUUID string = ""
	for _, v := range categories {
		if tagCategory == v.Name {
			categoryUUID = v.UUID
			break
		}
	}

	if categoryUUID == "" {
		trans.Infof("Creating category '%s' ... ", tagCategory)
		categoryUUID, err = trans.CreateTagCategory(tagCategory)
		if err != nil {
			cli.Println(fmt.Sprintf("%s", err))
			trans.Errorf("ERROR: %s", err)
			return err
		}
	}

	if tagValue != "" {
		log := fmt.Sprintf("Creating category:value '%s' for category '%s' [%s]", tagValue, tagCategory, categoryUUID)
		cli.Println(fmt.Sprintf("%s", log))

		trans.Infof(log)
		err = trans.CreateTagValue(categoryUUID, tagCategory, tagValue)
		if err != nil {
			return err
		}
		cli.Println(fmt.Sprintf("Successful TAGGED asset!"))
	}

	return err
}
func (t *Tags) ListTags(tagCategory string, tagValue string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)

	values, err := trans.GetTagValues()
	var tags[] dao.TagValue
	for _,v := range values {
		noParams:= tagValue == "" && tagCategory == "" //Should list ALL categories
		isCatMatch:=v.CategoryName == tagCategory 		 //This TAG matches CATEGORY
		isValMatch:=v.Value == tagValue 							 //This TAG matches the VALUE

		if noParams || (isCatMatch && isValMatch) || (isCatMatch && tagValue == "")   {
			tags = append(tags, v)			
		}
	}

	if len(tags) > 0 {
		cli.DrawTags(tags)
	}
	return err
}

func (t *Tags) DeleteTag(tagCategory string, tagValue string) (err error) {
	var trans = dao.NewTranslator(t.Config)

	if tagCategory == "" || tagValue == "" {
		err := errors.New("Error: Must specify a CATEGORY and VALUE - ie. a TAG, both.")
		trans.Errorf("%s", err)
		return err
	}

	values, err := trans.GetTagValues()

	if err != nil {
		trans.Errorf("ERROR:%s\n%s", err, values)
		return err
	}

	tagUUID := ""
	matched := false
	for _,v := range values {
		if v.CategoryName == tagCategory && v.Value == tagValue {
			tagUUID = v.UUID
			matched = true
			break
		}
	}
	if !matched {
		err = errors.New(fmt.Sprintf("ERROR: Couldn't find tag matching category:%s and value:%s", tagCategory, tagValue))
		trans.Errorf("%s", err)
	}

	trans.Infof(fmt.Sprintf("Calling DELETE on TAG UUID:'%s' - %s:%s", tagUUID, tagCategory, tagValue))
	trans.DeleteTagValue(tagUUID)

	return err
}
func (t *Tags) Tag(assetUUID string, tagCategory string, tagValue string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)

	trans.Infof(fmt.Sprintf("Tagging AssetUUID: %s with Category:%s Value:%s", assetUUID, tagCategory, tagValue))

	err = trans.TagByAssetUUID(assetUUID, tagCategory, tagValue)
	if err != nil {
		cli.Println(fmt.Sprintf("ERROR: %s\n", err))
	}
	return
}
func (t *Tags) Untag(assetUUID string, tagCategory string, tagValue string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)

	trans.Infof(fmt.Sprintf("Untagging AssetUUID: %s with Category:%s Value:%s", assetUUID, tagCategory, tagValue))

	err = trans.UntagByAssetUUID(assetUUID, tagCategory, tagValue)
	if err != nil {
		cli.Println(fmt.Sprintf("ERROR: %s", err))
	} else {
		cli.Println(fmt.Sprintf("Success!"))
	}
	return err
}

//  tio-cli asset --list --scanId=67
//
//  tio-cli tags --list
//  tio-cli tags --search --category "addenda-agents" --value "testagkph"
//
//  tio-cli tags --tag --category "addenda-agents" --value "testagkph" --scanId=67
//  tio-cli tags --tag --category "addenda-agents" --value "testagkph" --assetUUID=ae33eer-e39chha-cb44233
//  tio-cli tags --untag --category "addenda-agents" --value "testagkph" --scanId=67
//  tio-cli tags --create --category "addenda-agents" --value "testagkph"

//  tio-cli tags --delete --category "addenda-agents" --value "testagkph"
