package vulnerability

import (
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/whereiskurt/tio-cli/internal/pkg/tio"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/dao"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/ui"
)

type Tags struct {
	Config            *tio.VulnerabilityConfig
	Workers           *sync.WaitGroup
	ConcurrentWorkers int
}

func NewTags(config *tio.VulnerabilityConfig) *Tags {
	s := new(Tags)
	s.Config = config

	s.Workers = new(sync.WaitGroup)
	s.ConcurrentWorkers, _ = strconv.Atoi(config.Base.ConcurrentWorkers)

	return s
}

func (t *Tags) Execute() (err error) {

	var category string = t.Config.TagCategory
	var value string = t.Config.TagValue

	//CREATE or DELETE??
	if t.Config.Create == true {
		err = t.CreateTag(category, value)
		if err == nil {
			err = t.ListTags(category, value)
		}
		return err

	} else if t.Config.Delete == true {
		err = t.DeleteTag(category, value)
		if err == nil {
			err = t.ListTags(category, "")
		}
		return err
	}

	//LIST or SEARCH ??
	if !(t.Config.Tag || t.Config.Untag) {
		if t.Config.SearchView == true {
			err = t.SearchTags(category, value)
			return err

		} else if t.Config.ListView == true {
			err = t.ListTags(category, value)
			return err
		}
	}

	//TAG or UNGAG an asset
	//TODO: Split assetUUID and loop on a command-separated assetUUID list
	if t.Config.AssetUUID != "" {
		assetUUID := t.Config.AssetUUID
		if t.Config.Tag == true {
			err = t.Tag(assetUUID, category, value)

		} else if t.Config.Untag == true {
			err = t.Untag(assetUUID, category, value)

		}
		return err
	}

	//TAG or UNTAG many based on command parameters (--scanId, --hostId, etc.)
	err = t.LoopOnHostDetails(category, value)

	return err
}

func (t *Tags) LoopOnHostDetails(category string, value string) (err error) {

	var trans = dao.NewTranslator(t.Config)
	trans.Info("Executing tio.vulnerability.tags.Execute()")

	//Use the scan history and scanid,hostid,pluginid,etc.
	ch := make(chan dao.ScanHistory, 2)

	go trans.GoGetHostDetails(ch, 6)

	for rec := range ch {
		if len(rec.ScanHistoryDetails) == 0 {
			continue
		}
		scan := rec.ScanHistoryDetails[0]
		hosts := scan.Host
		for _, h := range hosts {
			assetUUID := h.Asset.UUID

			if t.Config.Tag == true {
				err = t.Tag(assetUUID, category, value)

			} else if t.Config.Untag == true {
				err = t.Untag(assetUUID, category, value)

			}

			if err != nil {
				trans.Errorf("ERROR: %s", err)

				break
			}

		}
	}

	return err
}
func (t *Tags) CreateTag(category string, value string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)

	if category == "" || value == "" {
		err = errors.New("ERROR: Must provide a CATEGORY NAME and VALUE.")
		cli.Println(fmt.Sprintf("%s", err))
		trans.Errorf("%s", err)
		return err
	}

	categories, err := trans.GetTagCategories()
	if err != nil {
		trans.Errorf("Error: %s", err)
		return err
	}

	var uuid string = ""
	for _, v := range categories {
		if category == v.Name {
			uuid = v.UUID
			break
		}
	}

	if uuid == "" {
		trans.Infof("Creating category '%s' ... ", category)
		uuid, err = trans.CreateTagCategory(category)
		if err != nil {
			cli.Println(fmt.Sprintf("%s", err))
			trans.Errorf("ERROR: %s", err)
			return err
		}
	}

	log := fmt.Sprintf("Creating category:value '%s' for category '%s' [%s]", value, category, uuid)
	cli.Println(fmt.Sprintf("%s", log))

	trans.Infof(log)
	err = trans.CreateTagValue(uuid, category, value)
	if err != nil {
		return err
	}
	cli.Println(fmt.Sprintf("Successful TAGGED asset!"))

	return err
}
func (t *Tags) ListTags(category string, value string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)

	values, err := trans.GetTagValues()
	if err != nil {
		return err
	}
	
	var tags []dao.TagValue
	for _, v := range values {
		noParams := value == "" && category == "" //Should list ALL categories
		isCatMatch := v.CategoryName == category  //This TAG matches CATEGORY
		isValMatch := v.Value == value            //This TAG matches the VALUE

		if noParams || (isCatMatch && isValMatch) || (isCatMatch && value == "") {
			tags = append(tags, v)
		}
	}

	if len(tags) > 0 {
		cli.DrawTags(tags)
	}
	return err
}

func (t *Tags) SearchTags(category string, value string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)
	var values []string

	if value != "" {
		//TODO: Add append to values
		values = append(values, value)

	} else {
		v, err := trans.GetTagValues()
		if err != nil {
			return err
		}

		for i := range v {
			if v[i].CategoryName == category {
				values = append(values, v[i].Value)
			}
		}
	}

	var assets []dao.AssetDetail
	for i := range values {
		searchAssets, err := trans.SearchAssetsByTag(category, values[i])
		if err != nil {
			return err
		}

		//Take the matching UUIDs and expand the object w/ GetAsset call
		for _, a := range searchAssets {
			asset, err := trans.GetAsset(a.UUID)
			if err != nil {
				return err
			}

			assets = append(assets, asset)
		}
	}

	cli.DrawSearchedAssetTable(assets)

	return err
}

func (t *Tags) DeleteTag(category string, value string) (err error) {
	var trans = dao.NewTranslator(t.Config)

	if category == "" || value == "" {
		err := errors.New("Error: Must specify a CATEGORY and VALUE - ie. a TAG, both.")
		trans.Errorf("%s", err)
		return err
	}

	values, err := trans.GetTagValues()

	if err != nil {
		trans.Errorf("ERROR:%s\n%s", err, values)
		return err
	}

	var tagUUID string = ""
	for _, v := range values {
		if v.CategoryName == category && v.Value == value {
			tagUUID = v.UUID
			break
		}
	}
	if tagUUID == "" {
		err = errors.New(fmt.Sprintf("ERROR: Couldn't find tag matching category:%s and value:%s", category, value))
		trans.Errorf("%s", err)
	}

	trans.Infof(fmt.Sprintf("Calling DELETE on TAG UUID:'%s' - %s:%s", tagUUID, category, value))
	trans.DeleteTagValue(tagUUID)

	return err
}
func (t *Tags) Tag(assetUUID string, category string, value string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)

	trans.Infof(fmt.Sprintf("Tagging '%s' with '%s:%s'", assetUUID, category, value))

	err = trans.TagByAssetUUID(assetUUID, category, value)
	if err != nil {
		cli.Println(fmt.Sprintf("ERROR: %s\n", err))
	}
	return
}
func (t *Tags) Untag(assetUUID string, category string, value string) (err error) {
	var trans = dao.NewTranslator(t.Config)
	var cli = ui.NewCommandLineInterface(t.Config)

	trans.Infof(fmt.Sprintf("Untagging AssetUUID: %s with Category:%s Value:%s", assetUUID, category, value))

	err = trans.UntagByAssetUUID(assetUUID, category, value)
	if err != nil {
		cli.Println(fmt.Sprintf("ERROR: %s", err))
	} else {
		cli.Println(fmt.Sprintf("Untagged success!"))
	}
	return err
}

//  tio-cli asset --list --scanId=67
//
//  tio-cli tags --list
//  tio-cli tags --search --category "addenda-agents" --value "testagkph"
//
//  tio-cli tags --tag --category "addenda-agents" --value "testagkph" --scanId=67
//  tio-cli tags --tag --category "addenda-agents" --value "testagkph" --assetUUID=ae33eer-e39chha-cb44233
//  tio-cli tags --untag --category "addenda-agents" --value "testagkph" --scanId=67
//  tio-cli tags --create --category "addenda-agents" --value "testagkph"

//  tio-cli tags --delete --category "addenda-agents" --value "testagkph"
