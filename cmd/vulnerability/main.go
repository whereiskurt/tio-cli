package tio

import (
	"fmt"
	"log"
	"os"
	"reflect"
	"time"

	homedir "github.com/mitchellh/go-homedir"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/whereiskurt/tio-cli/internal/pkg/tio"
)

const VulnerabilityVersion = "20180131"

var VulnConfig *tio.VulnerabilityConfig = tio.NewVulnerabilityConfig()

var MainVulnCmd = &cobra.Command{
	PreRun:             FinalizeConfig, //Note: Other subcommands refer to this.
	Run:                Main,
	SilenceUsage:       true,
	DisableSuggestions: true,
}

func VulnExecute() {
	cobra.OnInitialize(InitViperConfig)
	if err := MainVulnCmd.Execute(); err != nil {
		log.Fatal(fmt.Sprintf("ERROR: Couldn't execute root cmd: %v", err))
	}
	return
}
func Main(cmd *cobra.Command, args []string) {
	printMainUsage()
}

func printMainUsage() {
	fmt.Println(fmt.Sprintf(`

_|_ o  _ --- _  |  o 
 |_ | (_)   (_  |  |  [Release 0.5 Version ` + VulnerabilityVersion + `]
------------------------------------------------------------------------>
A command line tool for accessing Tenable.IO
                                              (written in Golang!)

  `))
	return
}

func init() {
	dts := time.Now().UTC().Format("20060102")

	addBoolFlag("useCryptoCache", &VulnConfig.Base.UseCryptoCache, "Should we encrypt local cache copy? [default:true]", true)

	addBoolFlag("noColourMode", &VulnConfig.Base.NoColourMode, "Disable colour output?", false)
	addBoolFlag("nocolour", &VulnConfig.Base.NoColourMode, "Disable colour output?", false)
	addBoolFlag("no-colour", &VulnConfig.Base.NoColourMode, "Disable colour output?", false)
	addBoolFlag("nocolor", &VulnConfig.Base.NoColourMode, "Disable colour output", false)
	addBoolFlag("no-color", &VulnConfig.Base.NoColourMode, "Disable colour output?", false)

	addBoolFlag("quiet", &VulnConfig.Base.QuietMode, "Minimize output - only errors to <<STDOUT>> [default:true]", true)

	addBoolFlag("clobberCache", &VulnConfig.Base.ClobberCache, "Overwrite the CACHE and do fresh lookups [default:false]", false)
	addBoolFlag("clobber", &VulnConfig.Base.ClobberCache, "Overwrite the CACHE and do fresh lookups [default:false]", false)

	addBoolFlag("quietMode", &VulnConfig.Base.QuietMode, "Minimize output - only errors to <<STDOUT>> [default:true]", true)

	addBoolFlag("offlineMode", &VulnConfig.Base.OfflineMode, "Stay offline - cache misses are skipped and not retrieve", false)
	addBoolFlag("offline", &VulnConfig.Base.OfflineMode, "Stay offline - cache misses are skipped and not retrieve", false)

	addBoolFlag("version", &VulnConfig.Base.DisplayVersionMode, "Output version and quit.", false)
	addBoolFlag("displayVersionMode", &VulnConfig.Base.DisplayVersionMode, "Output version and quit.", false)

	addStringFlag("verbose", &VulnConfig.Base.Verbose, "How much output to produce? [Range between 1-5, default: 3]", "3")

	addStringFlag("configFile", &VulnConfig.Base.ConfigFile, "Config file name or alias (default is $HOME/.tio-cli.yaml) must end '.yaml'", "")
	addStringFlag("config", &VulnConfig.Base.ConfigFile, "Config file name or alias (default is $HOME/.tio-cli.yaml) must end '.yaml'", "")

	addStringFlag("baseUrl", &VulnConfig.Base.BaseUrl, "Base URL for Tenable.IO", "https://cloud.tenable.com")
	addStringFlag("accessKey", &VulnConfig.Base.AccessKey, "Tenable.IO accessKey token.", "")
	addStringFlag("secretKey", &VulnConfig.Base.SecretKey, "Tenable.IO secretKey token.", "")

	addBoolFlag("cacheDisabled", &VulnConfig.Base.CacheDisabled, "By-pass all local caching mecahinsm [default:false]", false)
	addStringFlag("cacheKey", &VulnConfig.Base.CacheKey, "A secret key for the local cache.", "")
	addStringFlag("cacheFolder", &VulnConfig.Base.CacheFolder, "Where to store local cache? [default: cache/]", "cache/")

	addStringFlag("defaultTimezone", &VulnConfig.Base.DefaultTimezone, "Name of Timezone like '-0600 CST' [defaults: To local TZ.", "-0600 CST")
	addStringFlag("tz", &VulnConfig.Base.DefaultTimezone, "Name of Timezone like '-0600 CST' [defaults: To local TZ.", "-0600 CST")

	addStringFlag("output", &VulnConfig.Base.OutputFilename, "Name of the file to output results to [default: <<STDOUT>>", "")
	addStringFlag("outputFilename", &VulnConfig.Base.OutputFilename, "Name of the file to output results to [default: <<STDOUT>>", "")
	addStringFlag("outputFolder", &VulnConfig.Base.OutputFolder, "Name of the folder to write output results to [default: './'", "./")

	addStringFlag("log", &VulnConfig.Base.LogFilename, "Name of the log file [defaults: to logs/tio.DTS.log]", "logs/tio."+dts+".log")
	addStringFlag("logFilename", &VulnConfig.Base.LogFilename, "Name of the log file [defaults: to logs/tio.DTS.log]", "tio."+dts+".log")
	addStringFlag("logFolder", &VulnConfig.Base.LogFolder, "Name of the folder to write logs to [defaults: to logs/]", "logs/")

	addBoolFlag("outputFileAppend", &VulnConfig.Base.OutputFileAppend, "Append if file is already there? [default:true]", true)
	addBoolFlag("logFileAppend", &VulnConfig.Base.LogFileAppend, "Append to log if file is already there? [default:true]", true)

	addBoolFlag("outputCSVMode", &VulnConfig.Base.OutputCSVMode, "Output using CSV? [default:false]", false)
	addBoolFlag("csv", &VulnConfig.Base.OutputCSVMode, "Output using CSV? [default:false]", false)

	addBoolFlag("outputJSONMode", &VulnConfig.Base.OutputJSONMode, "Output using JSON? [default:false]", false)
	addBoolFlag("json", &VulnConfig.Base.OutputJSONMode, "Output using JSON? [default:false]", false)

	addStringFlag("scanId", &VulnConfig.ScanId, "Comma separated list of unique scan ids (eg. 1,2,3)", "")
	addStringFlag("ignoreScanId", &VulnConfig.IgnoreScanId, "Comma separated list of unique scan ids to ignore (eg. 1,2,3)", "")
	addStringFlag("historyId", &VulnConfig.HistoryId, "Comma separated list of unique history ids (eg. 1004124,100333)", "")
	addStringFlag("ignoreHistoryId", &VulnConfig.IgnoreHistoryId, "Comma separated list of unique history ids to ignore (eg. 1004124,100333)", "")
	
	addStringFlag("pluginId", &VulnConfig.PluginId, "Comma separated list of unique plugin ids (eg. 100424,97833)", "")
	addStringFlag("ignorePluginId", &VulnConfig.IgnorePluginId, "Comma separated list of unique plugin ids to ignore (eg. 100424,97833)", "")
	
	addStringFlag("pluginName", &VulnConfig.PluginName, "PluginName to regex match on.", "")
	addStringFlag("pluginFamilyName", &VulnConfig.PluginFamilyName, "PlugigFamilyName to regex match on.", "")


	addStringFlag("assetUUID", &VulnConfig.AssetUUID, "Comma separated list of unique asset UUIDs", "")
	addStringFlag("ignoreAssetUUID", &VulnConfig.IgnoreAssetUUID, "Comma separated list of unique asset UUIDs to ignore", "")
	addStringFlag("hostId", &VulnConfig.HostId, "Comma separated list of unique host ids", "")
	addStringFlag("ignoreHostId", &VulnConfig.IgnoreHostId, "Comma separated list of unique host ids to ignore", "")

	addStringFlag("depth", &VulnConfig.Depth, "How many levels back to go back? [default: 4] ", "1")
	addStringFlag("previous", &VulnConfig.Previous, "What is the offset? [default: 0]", "0")

	addBoolFlag("listView", &VulnConfig.ListView, "Should display output as a listing? [default:true]", true)
	addBoolFlag("list", &VulnConfig.ListView, "Should display output as a listing? [default:true]", true)

	addBoolFlag("search", &VulnConfig.SearchView, "Search view? [default:false]", false)
	addBoolFlag("searchView", &VulnConfig.SearchView, "Search view? [default:false]", false)

	addBoolFlag("detailView", &VulnConfig.DetailView, "Should display output as details? [default:false]", false)
	addBoolFlag("detail", &VulnConfig.DetailView, "Should display output as details? [default:false]", false)

	addBoolFlag("allView", &VulnConfig.AllView, " [default:false]", false)
	addBoolFlag("all", &VulnConfig.AllView, "Should display output as details? [default:false]", false)

	addStringFlag("regex", &VulnConfig.Regex, "? [default: none] ", "")
	addStringFlag("regexFields", &VulnConfig.RegexFields, "? [default: all fields]", "")

	addBoolFlag("create", &VulnConfig.Create, "Create? [default:false]", false)
	addBoolFlag("delete", &VulnConfig.Delete, "Delete? [default:false]", false)
	addBoolFlag("tag", &VulnConfig.Tag, "Tag? [default:false]", false)
	addBoolFlag("untag", &VulnConfig.Untag, "Untag? [default:false]", false)

	addStringFlag("tagCategory", &VulnConfig.TagCategory, "What is the tag category? [default: <none>]", "")
	addStringFlag("category", &VulnConfig.TagCategory, "What is the tag category? [default: <none>]", "")
	addStringFlag("tagValue", &VulnConfig.TagValue, "What is the tag value? [default: <none>]", "")
	addStringFlag("value", &VulnConfig.TagValue, "What is the tag value? [default: <none>]", "")

	addStringFlag("concurrentWorkers", &VulnConfig.Base.ConcurrentWorkers, "How many workers for Tenable.IO communication? [default: 3]", "6")

	//Private and clobbered by init's and such...
	addBoolFlag("isSuccessState", &VulnConfig.Base.IsSuccessState, "", false)
	addStringFlag("homeDir", &VulnConfig.Base.HomeDir, "", "")
	addStringFlag("executionDTS", &VulnConfig.Base.ExecutionDTS, "", "")

	MainVulnCmd.SetHelpFunc(mainHelp)
	MainVulnCmd.SetUsageFunc(mainUsage)

	return
}

//Read the configuration file (default from $HOMEDIR) and environment variables,
func InitViperConfig() {
	VulnConfig.Base.IsSuccessState = false
	VulnConfig.Base.ExecutionDTS = time.Now().UTC().Format(time.RFC3339)

	hdir, hErr := homedir.Dir()
	if hErr != nil {
		log.Fatal(fmt.Sprintf("Failed to initialize home directory: %v", hErr))
		return
	}

	VulnConfig.Base.HomeDir = hdir

	viper.AddConfigPath(hdir)

	viper.SetConfigName(".tio-cli")

	err := viper.ReadInConfig()
	if err != nil {
		return
	}

	if VulnConfig.Base.ConfigFile != "" {
		viper.AddConfigPath("./configs/")
		viper.SetConfigName(VulnConfig.Base.ConfigFile)

		err := viper.MergeInConfig()
		if err != nil {
			return
		}
	}

	viper.AutomaticEnv() // read in environment variables that match

	VulnConfig.Base.IsSuccessState = true
	return
}

//Copies the viper parsed commandline, env, and config file value to the
//to pkg.VulnerabilityConfig struct.
func FinalizeConfig(cmd *cobra.Command, args []string) {
	//Load the configuration from viper
	ReflectIntoConfig(VulnConfig)
	ReflectIntoConfig(VulnConfig.Base)

	outputFilename := fmt.Sprintf("%s/%s", VulnConfig.Base.OutputFolder, VulnConfig.Base.OutputFilename)
	logFilename := fmt.Sprintf("%s/%s", VulnConfig.Base.LogFolder, VulnConfig.Base.LogFilename)

	if outputFilename == ".//" {
		VulnConfig.Base.Output = os.Stdout
	} else {
		filemode := os.O_CREATE | os.O_WRONLY
		if VulnConfig.Base.OutputFileAppend {
			filemode = filemode | os.O_APPEND
		}
		// If the file doesn't exist, create it, or append to the file
		fh, err := os.OpenFile(outputFilename, filemode, 0644)
		if err != nil {
			log.Fatal(err)
		}
		VulnConfig.Base.Output = fh
	}

	if logFilename == "/" {
		VulnConfig.Base.LogFileHandle = os.Stdout
	} else {
		filemode := os.O_CREATE | os.O_WRONLY
		if VulnConfig.Base.LogFileAppend {
			filemode = filemode | os.O_APPEND
		}
		// If the file doesn't exist, create it, or append to the file
		fh, err := os.OpenFile(logFilename, filemode, 0644)
		if err != nil {
			log.Fatal(err)
		}
		VulnConfig.Base.LogFileHandle = fh
	}

	VulnConfig.Base.Logger = tio.NewLogger(VulnConfig.Base)

	return
}

//For each field in that c try and get the viper value and set it.
func ReflectIntoConfig(c tio.ReflectIntoConfig) {
	s := reflect.ValueOf(c).Elem()
	for i := 0; i < s.NumField(); i++ {
		name := s.Type().Field(i).Name
		ttype := fmt.Sprintf("%s", s.Field(i).Type())
		switch ttype {
		case "string":
			c.SetString(name, viper.GetString(name))
			break
		case "bool":
			c.SetBool(name, viper.GetBool(name))
			break
		default:
			//  TODO: Maybe add more typs..
			//  log.Println(fmt.Sprintf("C:[%s]:[%s]:[%s]", ttype, name, viper.GetString(name)))
		}
	}
}

func mainHelp(cmd *cobra.Command, args []string) {
	printMainUsage()
	return
}
func mainUsage(cmd *cobra.Command) error {
	printMainUsage()
	return nil
}

func addStringFlag(name string, addr *string, description string, defaultValue string) {
	MainVulnCmd.PersistentFlags().StringVar(addr, name, defaultValue, description)
	viper.BindPFlag(name, MainVulnCmd.PersistentFlags().Lookup(name))
	return
}
func addBoolFlag(name string, addr *bool, description string, defaultValue bool) {
	MainVulnCmd.PersistentFlags().BoolVar(addr, name, defaultValue, description)
	viper.BindPFlag(name, MainVulnCmd.PersistentFlags().Lookup(name))
	return
}
