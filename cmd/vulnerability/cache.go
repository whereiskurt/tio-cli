package tio

import (
	"fmt"

	"github.com/spf13/cobra"
	"github.com/whereiskurt/tio-cli/internal/app/tio/vulnerability"
	"github.com/whereiskurt/tio-cli/internal/pkg/tio/ui"
)

var ShouldAnon bool = false
var SyncMode bool = false
var PurgeMode bool = false
var CacheFolderWrite string

//Cobra sub-command
var cacheCmd = &cobra.Command{
	Aliases: []string{"cache"},
	Use:     "cache",
	PreRun:  MainVulnCmd.PreRun,
	Run:     mainCache,
}

func init() {
	MainVulnCmd.AddCommand(cacheCmd)
	cacheCmd.SetHelpFunc(helpOutputCache)
	cacheCmd.SetUsageFunc(usageOutputCache)

	//NOTE: This whole block can be added back to the main.go, or removed if
	//	    a separate subcommand config object is made.
	addBoolFlag("anon", &ShouldAnon, "Should we anonymize the results? [default:false]", false)
	addBoolFlag("anonymize", &ShouldAnon, "Should we anonymize the results? [default:false]", false)
	addBoolFlag("sync", &SyncMode, "Sync-mode will detel indexes and and sychronize with Tenable.IO. [default:false]", false)
	addBoolFlag("purge", &PurgeMode, "Delete folder with full details. [default:false]", false)
	addStringFlag("cacheFolderWrite", &CacheFolderWrite, "Output cache folder for anonymized data", "cache.obfu/")
	return
}

func helpOutputCache(cmd *cobra.Command, args []string) {
	printCacheHelp()
	return
}
func usageOutputCache(cmd *cobra.Command) error {
	printCacheHelp()
	return nil
}

func printCacheHelp() {
	fmt.Println(fmt.Sprintf(`
CACHE
----------------------------->
ScanId: %s
Anonymize: %v
  `, VulnConfig.ScanId, ShouldAnon))
	return
}

func mainCache(cmd *cobra.Command, args []string) {
	cli := ui.NewCommandLineInterface(VulnConfig)
	cli.DrawTioBanner()
	cli.DrawGopher()
	cli.Println("")

	configSuccess := VulnConfig.Base.IsSuccessState
	if !configSuccess {
		configSuccess := cli.PromptForConfigKeys()
		if !configSuccess {
			return
		}
	}


	//NOTE: Break this out into a separate sub-command config object
	VulnConfig.ShouldAnon = ShouldAnon
	VulnConfig.SyncMode = SyncMode
	VulnConfig.CacheFolderWrite = CacheFolderWrite

	c := vulnerability.NewCache(VulnConfig)

	c.Execute()
	return
}
