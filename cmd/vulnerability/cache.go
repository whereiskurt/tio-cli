package vulnerability

import (
  "tio-cli/api/tenable"
  "tio-cli/api/util"
  "tio-cli/cmd/colour"
  "fmt"
  "io/ioutil"
  "log"
  "sort"
  "regexp"
  "strconv"
  "strings"
  "encoding/json"
  "bufio"
  "os"
  "os/exec"
  "bytes"
  "path/filepath"

  "github.com/spf13/cobra"
  "github.com/spf13/viper"
)

var CACHE_FOLDER string = "./cache/scans/"  

var cacheCLI CacheCLIParams
type CacheCLIParams struct {
  HistoryId string
  WarnOutputOnly bool
  DeleteFromEverywhere bool
  DeleteFromCache bool

  PrettyPrintWithJQ bool
  Anonymize bool
  
  ShouldDecryptCache bool
  ShouldEncryptCache bool

  TargetFolderName string
  
}

func init() { 
  CacheCmd.PersistentFlags().StringVar(&cacheCLI.HistoryId, "historyid", "", "The history_id for the cache operation.")
  CacheCmd.PersistentFlags().StringVar(&cacheCLI.HistoryId, "history", "", "The history_id for the cache operation.")

  CacheCmd.PersistentFlags().BoolVar(&cacheCLI.WarnOutputOnly, "warn", false, "Only output entries with WARNINGS.")
  CacheCmd.PersistentFlags().BoolVar(&cacheCLI.DeleteFromEverywhere, "deletefromeverywhere", false, "PERMANENTLY delete from Tenable.IO and locally.")
  
  CacheCmd.PersistentFlags().BoolVar(&cacheCLI.DeleteFromCache, "deletefromcache", false, "Delete from local cache.")
  CacheCmd.PersistentFlags().BoolVar(&cacheCLI.DeleteFromCache, "delete", false, "Delete from local cache.")

  CacheCmd.PersistentFlags().StringVar(&cacheCLI.TargetFolderName, "targetFolder", "./output/", "Default for decrypt/encrypt output.")
  CacheCmd.PersistentFlags().StringVar(&cacheCLI.TargetFolderName, "output", "./output/", "Default for decrypt/encrypt output.")

  CacheCmd.PersistentFlags().BoolVar(&cacheCLI.ShouldEncryptCache, "encrypt", false, "")
  CacheCmd.PersistentFlags().BoolVar(&cacheCLI.ShouldDecryptCache, "decrypt", false, "")
  CacheCmd.PersistentFlags().BoolVar(&cacheCLI.PrettyPrintWithJQ, "pretty", false, "")
  CacheCmd.PersistentFlags().BoolVar(&cacheCLI.Anonymize, "anonymize", false, "")

  viper.BindPFlag("historyid", CacheCmd.PersistentFlags().Lookup("historyid"))
  viper.BindPFlag("warn", CacheCmd.PersistentFlags().Lookup("warn"))
  viper.BindPFlag("deletefromeverywhere", CacheCmd.PersistentFlags().Lookup("deletefromeverywhere"))

  viper.BindPFlag("targetFolder", CacheCmd.PersistentFlags().Lookup("targetFolder"))
  viper.BindPFlag("encrypt", CacheCmd.PersistentFlags().Lookup("encrypt"))
  viper.BindPFlag("decrypt", CacheCmd.PersistentFlags().Lookup("decrypt"))
  return
}


var CacheCmd = &cobra.Command{
  Use:   "cache",
  Short: "Output cache details.",
  Long: `
CACHE
#####################
EXAMPLES: 
  ##List all cache details
  $ tio cache
`,
  Run: func(cmd *cobra.Command, args []string) {
    var portal = tenable.NewPortal()
    mainCache(portal)
  },
}

func mainCache(portal *tenable.Portal) {
  cacheFolder := viper.GetString("cacheFolder")
  targetFolder := viper.GetString("targetFolder")
  useCryptoCache := viper.GetBool("useCryptoCache")
  key := viper.GetString("cacheKey")

  if cacheCLI.ShouldDecryptCache {
    CryptCache("decrypt", cacheFolder, targetFolder, key, useCryptoCache)

  } else if cacheCLI.ShouldEncryptCache {
    CryptCache("encrypt", cacheFolder, targetFolder, key, useCryptoCache)

  } else {
    ScanHostCrawler(portal)
  }

  return
}

func CryptCache(function string, source string, target string, key string, useCryptoCache bool) {
  usejq := cacheCLI.PrettyPrintWithJQ
  anon := cacheCLI.Anonymize

  //Remove the './' from the start
  if strings.HasPrefix(source, "./") { source = strings.Replace(source, "./", "", 1) }
  if strings.HasPrefix(target, "./") { target = strings.Replace(target, "./", "", 1) }

  //Folders need to end w/ "/"
  if ! strings.HasSuffix(source, "/") { source = source + "/" }
  if ! strings.HasSuffix(target, "/") { target = target + "/" }

  fmt.Println(fmt.Sprintf("-> Reading encrypted folder '" + colour.GREEN + "%v" + colour.RESET + "' and outputing contents to '" + colour.GREEN + "%v" + colour.RESET + "'", source, target)) 

  e := filepath.Walk(source, func(path string, f os.FileInfo, err error) error {
    writePath := strings.Replace(path, source, target, 1)

    if f.IsDir() { 
      errMkdir := os.MkdirAll(writePath, 0777)
      if errMkdir != nil {
        fmt.Println(fmt.Sprintf(colour.RED + "Failed to make directory: %v" + colour.RESET, errMkdir)) 
        return errMkdir
      }
      return err 
    }

    in, readerr := ioutil.ReadFile(path)
    if readerr != nil { return readerr }

    var output []byte
    if function == "decrypt" {
      if useCryptoCache {
        plain, err := util.Decrypt(in, []byte(key))
        if err != nil { return err }
        output = plain       
      } else {
        output = in
      }

      if usejq {
        cmd := exec.Command("jq", ".")
        cmd.Stdin = strings.NewReader(string(output))
        var out bytes.Buffer
        cmd.Stdout = &out
        err := cmd.Run()
        if err != nil { log.Fatal(err) }

        output = []byte(out.String())
      }


      reScans := regexp.MustCompile(".*?/scans/\\d+")

      if anon {
        if strings.Contains(path, "plugin") {

        } else if strings.Contains(path, "hosts") {
          //url: scans/55/history_id=12/hosts/23432/hostdetail.json
          output = AnonymizePrivateIP(output)
          output = AnonymizeFQDN(output)

        } else if strings.Contains(path, "history_id") {
          //url: scans/55/history_id=12/scandetail.json
          output = AnonymizePrivateIP(output)
          output = AnonymizeScanName(output)

        } else if reScans.MatchString(path) { 
          //url: scans/55/scandetail.json
          output = AnonymizePrivateIP(output)
          output = AnonymizeScanName(output)

        } else {
          //url: scans/scans.json
          output = AnonymizePrivateIP(output)
          output = AnonymizeScanName(output)
          
        }
      }

    } else if function == "encrypt" {
      cipher, err := util.Encrypt(in, []byte(key))
      if err != nil { return err }
      output = cipher    
    }

    return ioutil.WriteFile(writePath, output, 0644)
  })

  if e != nil {
    fmt.Println(fmt.Sprintf(colour.RED + "Failure: %v" + colour.RESET, e)) 
    return
  }

  return
}
func AnonymizeScanName(data []byte) []byte {
  reName := regexp.MustCompile("\"name\":\\s*\".*?\"")
  data = reName.ReplaceAllFunc(data, func(s []byte) []byte {
    return []byte("\"name\": \"" + util.PopularEnglishAnimalPhrase() + "\"")
  })
  
  reNetbios := regexp.MustCompile("\"netbios-name\":\\s*\".*?\"")
  data = reNetbios.ReplaceAllFunc(data, func(s []byte) []byte {
    return []byte("\"name\": \"" + util.PopularEnglishAnimalPhrase() + "\"")
  })

  return data
}
func AnonymizeFQDN(data []byte) []byte {
  re := regexp.MustCompile("\"host-fqdn\":\\s*\".*?\"")
  data = re.ReplaceAllFunc(data, func(s []byte) []byte {
    return []byte("\"host-fqdn\": \"" + strings.ToLower(util.Hostname("scanme.org") + "\""))
  })
  return data
}

func AnonymizePrivateIP(data []byte) []byte {
  re := regexp.MustCompile("\\d+\\.\\d+\\.\\d+\\.\\d+")
  data = re.ReplaceAllFunc(data, func(s []byte) []byte {
    return []byte(util.FakePrivateIpv4([]byte{10}))
  })
  return data
}

func AnonymizeIP(data []byte) []byte {
  re := regexp.MustCompile("\\d+\\.\\d+\\.\\d+\\.\\d+")
  data = re.ReplaceAllFunc(data, func(s []byte) []byte {
    return []byte(util.FakeIpv4())
  })
  return data
}



func ScanHostCrawler(portal *tenable.Portal) {
  var matchScanId = GetCLIScanIds(portal) 

  scans, err := ioutil.ReadDir(CACHE_FOLDER)
  if err != nil {
    log.Fatal(err)
  }
  var scanCount = len(scans) - 1

  sort.Slice(scans, func(i, j int) bool {
    var iStr string
    var jStr string

    iStr = scans[i].Name()
    jStr = scans[j].Name()
    
    iv, iverr := strconv.ParseInt(iStr, 10, 64)
    if iverr != nil {
        return true
    }
    jv, jverr := strconv.ParseInt(jStr, 10, 64)
    if jverr != nil {
        return false
    }
    return iv > jv
  })

  var scanDetailsPath = ""

  //1. For each of the scans...
  fmt.Println(fmt.Sprintf("-> BEGIN: Looking through '%v' at " + colour.GREEN + "%v" + colour.RESET+ "' locally cached scans...", CACHE_FOLDER, scanCount))
  for _, scanFolder := range scans {
    if ! scanFolder.IsDir() {
      fmt.Println(fmt.Sprintf("-> INFO: Scan details found in '" + colour.GREEN +  "%v" + colour.RESET +  "'",CACHE_FOLDER + scanFolder.Name() ))
      scanDetailsPath = CACHE_FOLDER + "/" + scanFolder.Name()
      continue
    }
    
    var scanId = scanFolder.Name()
    var matched bool = len(matchScanId) == 0
    for _, s := range matchScanId {
      if fmt.Sprintf("%v", s) == scanId {
        matched = true
        break
      }
    }
    if !matched {
      continue
    }

    var scanName = portal.GetScanName(scanId)
    var scanFolderItems, _ = ioutil.ReadDir(CACHE_FOLDER + scanId)
    var historyCount = len(scanFolderItems) - 1  //-1 because the FILE in this folder is the scandetails for historyindex[0]

    fmt.Println(fmt.Sprintf("-> INFO: '" + colour.BOLD + "%v" + colour.RESET + "' (" + colour.BOLD +  "%v" + colour.RESET +  ") has " + colour.GREEN +  "%v" + colour.RESET +  " locally cached items ...",scanName, scanId, historyCount ))

    sort.Slice(scanFolderItems, func(i, j int) bool {
      var iStr string
      var jStr string

      iStr = strings.Replace(scanFolderItems[i].Name(), "history_id=", "", -1)
      jStr = strings.Replace(scanFolderItems[j].Name(), "history_id=", "", -1)
      
      iv, iverr := strconv.ParseInt(iStr, 10, 64)
      if iverr != nil {
          return true
      }
      jv, jverr := strconv.ParseInt(jStr, 10, 64)
      if jverr != nil {
          return false
      }
      return iv > jv
    })    

    var scanDetailsChanged bool = false

    for i, item := range scanFolderItems {
      if ! item.IsDir() {
        continue
      }
      
      //ONLY Directories here.
      var historyId = item.Name()
      var historyPath = CACHE_FOLDER + scanId + "/" + historyId + "/"

      var sd tenable.ScanDetails
      var hostCountReport int64 = 0

      var historyFolderItems, _ = ioutil.ReadDir(historyPath)
      for _, item := range historyFolderItems {
        if ! item.IsDir() {

          var tenableEndPoint = "scans/" + scanId + "?" + historyId
          var cacheFolder = "scans/" + scanId + "/" + historyId 
          raw := portal.Get(tenableEndPoint, "GET", cacheFolder)
          err := json.Unmarshal([]byte(string(raw)), &sd)

          if err != nil {
            fmt.Println(fmt.Sprintf("  -> WARN: Couldn't load details '" + colour.RED +  "%v" + colour.RESET + "'", historyPath + item.Name()))
          } else {
            hostCountReport, _ = strconv.ParseInt(string(sd.Info.HostCount), 10, 64)
          }

          break
        }
      }

      var hostPath = historyPath + "/hosts/"

      var hostFolderItems, _ = ioutil.ReadDir(hostPath)
      var hostCountActual int = len(hostFolderItems)

      var status = colour.RED + "WARN: MISSING hosts!!" + colour.RESET
      if hostCountReport == 0 && hostCountActual != 0 {
        status = colour.YELLOW + "RE-SYNC" +colour. RESET
        if cacheCLI.WarnOutputOnly {
          continue
        }
      } else if int64(hostCountActual) == hostCountReport {
        status = colour.GREEN + "OK" + colour.RESET
        if cacheCLI.WarnOutputOnly {
          continue
        }
      } else if int64(hostCountActual) >= hostCountReport {
        status = colour.RED + "WARN: TOO many hosts!" + colour.RESET  
      }

      fmt.Println(fmt.Sprintf("    -> INFO: Offset(%v):'" + colour.GREEN +  "%v" + colour.RESET +  "' cached '" + colour.BOLD +  "%v" + colour.RESET + "' hosts ondisk '" + colour.BOLD + "%v" + colour.RESET + "' expected [%s]" , i-1, historyPath, hostCountActual, hostCountReport, status )) 

      if cacheCLI.DeleteFromEverywhere {
        scanDetailsChanged = PromptHistoryDeleteFromEverywhere(portal, historyPath) || scanDetailsChanged
      } else if cacheCLI.DeleteFromCache {
        scanDetailsChanged = PromptHistoryDeleteFromLocal(historyPath) || scanDetailsChanged
      }

    }
    if scanDetailsChanged {
      fmt.Println(fmt.Sprintf("-> " + colour.BOLD + "REMOVING " + colour.RESET + " history details '%v', became invalidated.", scanDetailsPath))
      os.Remove(scanDetailsPath)
    }

  }
  fmt.Println(colour.BOLD + fmt.Sprintf("-> END: Done cached scans...") + colour.RESET)
}

func PromptHistoryDeleteFromEverywhere(portal *tenable.Portal, historyPath string) bool {
  reader := bufio.NewReader(os.Stdin)

  fmt.Print("    *** This history will be ", colour.BOLD, "PERMANENTLY DELETED EVERYWHERE", colour.RESET, "*** \n    *** Remote and local copies will be deleted!\n" + colour.RED + "       --> THIS WILL BE UNRECOVERABLE <--\n" + colour.RESET + "    Delete this history from" + colour.BOLD + " EVERYWHERE " + colour.RESET + " (Yes / " + colour.BOLD + "NO" + colour.RESET + ")?: ")
  shouldDelete, _ := reader.ReadString('\n')
  fmt.Println("")
  shouldDelete = strings.TrimSpace(shouldDelete)
  if shouldDelete == "yes" {

    var compRegEx = regexp.MustCompile(".+/scans/(?P<scanId>.*?)/history_id=(?P<historyId>.*?)/")
    match := compRegEx.FindStringSubmatch(historyPath)
    scanId := match[1]
    historyId := match[2]

    fmt.Println(fmt.Sprintf("      BEGIN: " + colour.BOLD + "DELETING" + colour.RESET + " scanId: " + colour.BOLD + "%v" + colour.RESET +", from historyId: " + colour.BOLD + "%v" + colour.RESET + "...", scanId, historyId))

    fmt.Println(fmt.Sprintf("        -> HTTP " + colour.BOLD + "DELETE /scans/%v/history/%v" + colour.RESET, scanId, historyId))
    portal.Delete(fmt.Sprintf("/scans/%v/history/%v", scanId, historyId))

    fmt.Println(fmt.Sprintf("        -> RMDIR " + colour.BOLD + "%v" + colour.RESET, historyPath))
    os.RemoveAll(historyPath)

    fmt.Println(fmt.Sprintf(colour.BOLD + "      DONE! " + colour.RESET))

    return true
  }

  return false
}

func PromptHistoryDeleteFromLocal(historyPath string) bool {
  reader := bufio.NewReader(os.Stdin)

  fmt.Print("    *** This history will be ", colour.BOLD, "LOCALLY DELETED", colour.RESET, " from the cache. *** \n    *** The cached copy will be removed from the filesystem!\n" + "    Delete this history from" + colour.BOLD + " LOCAL CACHE " + colour.RESET + " (Yes / " + colour.BOLD + "NO" + colour.RESET + ")?: ")
  shouldDelete, _ := reader.ReadString('\n')
  fmt.Println("")
  shouldDelete = strings.TrimSpace(shouldDelete)
  if shouldDelete == "yes" {

    fmt.Println(fmt.Sprintf("        -> RMDIR " + colour.BOLD + "%v" + colour.RESET, historyPath))
    os.RemoveAll(historyPath)

    fmt.Println(fmt.Sprintf(colour.BOLD + "      DONE! " + colour.RESET))

    return true
  }

  return false
}