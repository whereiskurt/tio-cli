package vulnerability

import (
  "fmt"
  "strings"
  "tio-cli/api/tenable"
  "github.com/spf13/viper"
  "log"
  "strconv"
  "time"
  "io"
  "io/ioutil"
  "os"
  "path/filepath"
)

//Convenience function for getting ALL scansids
func GetCLIScanIds(portal *tenable.Portal) []string {
  var includeIds string = viper.GetString("scanid")
  var ignoreScans [] string  = strings.Split(viper.GetString("ignoreScans"), ",")

  if (includeIds == "") {
    s := portal.GetScanList()

    if len(s.Scans) == 0 {
      log.Fatal("ERROR:  There are no scans or your credentials are invalid.")
    }

    ScanList:
    for _, e := range s.Scans {
      for _, c := range ignoreScans {
        if string(e.Id) == c { continue ScanList}
      }
      includeIds += fmt.Sprintf("%v,", e.Id)
    }
    includeIds = includeIds[:len(includeIds)-1] 
  }

  return strings.Split(includeIds, ",")
}

func GetCLIPluginIds() []string{
  var pluginIds string = viper.GetString("plugins")

  return strings.Split(pluginIds, ",")
}

func GetCLICollectKey() string {
  var collectKey = "HostIP"
  if viper.GetBool("byHostFQDN") {
    collectKey = "HostFQDN"
  }
  return collectKey
}

func GetCLIDepth() int {
  var depth, err = strconv.Atoi( viper.GetString("depth") )
  if err != nil {
    log.Fatal("Invalid --depth parameter - likely not a number.")
  }

  return depth
}

func UnixTimePretty(unix string) string {
  var rawUnixInt, err = strconv.ParseInt(string(unix), 10, 64)
  if err != nil {
    rawUnixInt =  int64(0) 
  }
  var unixFirstStart = time.Unix(rawUnixInt, 0)

  var prettyDate = fmt.Sprintf("%v", unixFirstStart)

  return prettyDate
}
//////


// Copy copies src to dest, doesn't matter if src is a directory or a file
func Copy(src, dest string) error {
  info, err := os.Stat(src)
  if err != nil {
    return err
  }
  if info.IsDir() {
    return dcopy(src, dest, info)
  }
  return fcopy(src, dest, info)
}

func fcopy(src, dest string, info os.FileInfo) error {

  if info == nil {
    i, err := os.Stat(src)
    if err != nil {
      return err
    }
    info = i
  }

  f, err := os.Create(dest)
  if err != nil {
    return err
  }
  defer f.Close()

  if err = os.Chmod(f.Name(), info.Mode()); err != nil {
    return err
  }

  s, err := os.Open(src)
  if err != nil {
    return err
  }
  defer s.Close()

  if _, err = io.Copy(f, s); err != nil {
    return err
  }
  return nil
}

func dcopy(src, dest string, info os.FileInfo) error {
  if info == nil {
    i, err := os.Stat(src)
    if err != nil {
      return err
    }
    info = i
  }
  if err := os.MkdirAll(dest, info.Mode()); err != nil {
    return err
  }
  infos, err := ioutil.ReadDir(src)
  if err != nil {
    return err
  }
  for _, info := range infos {
    if info.IsDir() {
      dcopy(
        filepath.Join(src, info.Name()),
        filepath.Join(dest, info.Name()),
        info,
      )
    } else {
      fcopy(
        filepath.Join(src, info.Name()),
        filepath.Join(dest, info.Name()),
        info,
      )
    }
  }
  return nil
}